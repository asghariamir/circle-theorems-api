<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Theorems - Interactive App</title>
    <style>
        :root {
            --primary-color: #1565c0; /* Blue */
            --secondary-color: #c62828; /* Red for highlights */
            --highlight-color: #ff8f00; /* Orange for unknown angles */
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #424242;
            --text-color: #212121;
            --success-color: #4caf50;
            --error-color: #f44336;
        }

        /* --- Global Styles & Structure --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6; background-color: var(--light-gray); color: var(--text-color); padding: 1rem;
        }
        .container {
            width: 100%; max-width: 1200px; margin: 1rem auto; background-color: white;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1); border-radius: 12px; padding: 2rem;
        }
        h1 { font-size: 2.2rem; color: var(--primary-color); margin-bottom: 2rem; text-align: center; }
        h2 { font-size: 1.5rem; color: var(--dark-gray); margin-bottom: 1rem; }
        h3 { font-size: 1.2rem; color: var(--primary-color); margin-bottom: 1rem; }

        /* --- Tabs --- */
        .tabs { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 2rem; border-bottom: 2px solid var(--medium-gray); }
        .tab {
            padding: 0.75rem 1.5rem; background: none; border: none; cursor: pointer; font-size: 1.1rem;
            color: var(--dark-gray); transition: all 0.3s ease; border-bottom: 4px solid transparent; transform: translateY(2px);
        }
        .tab.active { color: var(--primary-color); border-bottom-color: var(--primary-color); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* --- Layout & SVG --- */
        .main-layout { display: grid; grid-template-columns: 1fr; gap: 1.5rem; }
        .diagram-container { width: 100%; max-width: 600px; margin: 0 auto; }
        svg { width: 100%; height: auto; display: block; user-select: none; background-color: #fdfdfd; border-radius: 8px; cursor: default; border: 1px solid var(--medium-gray); }
        .point-label, .feature-label { font-family: sans-serif; font-size: 16px; font-weight: bold; }
        .point-label { cursor: pointer; } /* Make labels clickable for renaming */
        .feature-label { fill: var(--dark-gray); }

        /* Enhanced styling for intro tab */
        .intro-content {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        .theorem-box {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .theorem-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }
        .theorem-box h3 {
            color: var(--primary-color);
            font-size: 1.3rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .theorem-box h3::before {
            content: "💡";
            font-size: 1.2rem;
        }
        .theorem-box p {
            margin-bottom: 0.8rem;
            line-height: 1.7;
        }
        .theorem-box strong {
            color: var(--secondary-color);
        }

        /* --- Animations & Highlights --- */
        @keyframes pulse { 0%, 100% { stroke-width: 5; opacity: 1; } 50% { stroke-width: 8; opacity: 0.7; } }
        .key-arc-highlight, .builder-arc { stroke: var(--secondary-color); stroke-width: 6; stroke-linecap: round; fill: none; }
        .key-arc-highlight { animation: pulse 1.5s infinite ease-in-out; }
        .selected-outline { stroke: var(--secondary-color) !important; stroke-width: 5px !important; opacity: 1 !important; }
        .unknown-angle-highlight { stroke: var(--highlight-color); stroke-width: 4; }

        /* --- Problem Builder & Practice Tab --- */
        .builder-intro-box {
            background-color: #e3f2fd; /* Light blue */
            border-left: 4px solid var(--primary-color);
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 8px;
        }
        .builder-intro-box p {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }
        .builder-intro-box ul {
            list-style-position: inside;
            padding-left: 0.5rem;
        }
        .builder-intro-box li {
            margin-bottom: 0.25rem;
        }
        .ai-disclaimer {
            font-size: 0.85rem;
            font-style: italic;
            color: var(--dark-gray);
            margin-top: 1rem;
            border-top: 1px solid var(--medium-gray);
            padding-top: 0.5rem;
        }
        .toolbox-section {
            background-color: var(--light-gray);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        .toolbox-section h4 {
            font-size: 1.1rem;
            color: var(--dark-gray);
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--medium-gray);
            padding-bottom: 0.5rem;
        }
        .tool-buttons-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 0.75rem;
        }
        .tool-btn {
            padding: 0.5rem 1rem; background: #fff; color: var(--dark-gray); border: 2px solid var(--medium-gray);
            border-radius: 6px; cursor: pointer; font-size: 0.9rem; 
            text-align: left;
            transition: transform 0.15s cubic-bezier(0.2, 0.8, 0.4, 1.2), background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }
        .tool-btn:hover {
            transform: scale(1.05);
        }
        .tool-btn:active {
            transform: scale(0.95);
            transition-duration: 0.05s;
        }
        .tool-btn.active { 
            background: var(--primary-color); color: white; border-color: var(--primary-color); font-weight: bold;
            transform: scale(1.02);
        }
        .tool-btn:disabled { background: #e0e0e0; color: #9e9e9e; cursor: not-allowed; transform: none; }
        .problem-info { text-align: left; background-color: var(--light-gray); padding: 1rem; border-radius: 8px; min-height: 80px; font-family: 'Courier New', Courier, monospace; line-height: 1.4; margin-top: 1rem; }
        .selectable:hover { stroke-width: 8px !important; opacity: 0.7; cursor: pointer; }
        .draggable-point:hover { cursor: move; }
        .question-box { background-color: #fff; border: 2px solid var(--primary-color); padding: 1rem; margin-top: 1rem; border-radius: 8px; min-height: 50px;}
        
        /* Spacing for Practice Tab inputs */
        .input-group { display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem; }
        .angle-input {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.5rem; /* Space between each input row */
        }
        .angle-input label { font-weight: bold; justify-self: end; }
        .angle-input input, .challenge-textarea { 
            padding: 0.75rem; 
            border: 2px solid var(--medium-gray); 
            border-radius: 4px; 
            font-size: 1.1rem;
            transition: border-color 0.2s ease;
            width: 100%;
        }
        .angle-input input:focus, .challenge-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(21, 101, 192, 0.1);
        }
        .angle-input input.error { border-color: var(--error-color); }
        .button-group { display: flex; gap: 1rem; justify-content: center; margin-top: 2rem; }
        .button-group button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .button-group button:first-child {
            background: var(--success-color);
            color: white;
        }
        .button-group button:first-child:hover {
            background: #45a049;
            transform: translateY(-1px);
        }
        .button-group button:last-child {
            background: var(--primary-color);
            color: white;
        }
        .button-group button:last-child:hover {
            background: #1565c0;
            transform: translateY(-1px);
        }
        .feedback { margin-top: 1.5rem; padding: 1rem; border-radius: 4px; text-align: center; font-weight: bold; min-height: 50px; }
        .feedback.success { background: #e8f5e9; color: var(--success-color); }
        .feedback.error { background: #ffebee; color: var(--error-color); }

        @media (max-width: 900px) { .main-layout { grid-template-columns: 1fr; } .diagram-container { position: static; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Circle Theorems Interactive</h1>
        <div class="tabs">
            <button class="tab active" data-tab="intro">Introduction</button>
            <button class="tab" data-tab="practice">Practice Problems</button>
            <button class="tab" data-tab="create">Problem Builder</button>
        </div>
        <div id="intro" class="tab-content active"></div>
        <div id="practice" class="tab-content"></div>
        <div id="create" class="tab-content"></div>
    </div>

    <script>
    const SVG_NS = "http://www.w3.org/2000/svg";
    const CX = 200, CY = 200, R = 150;
    let introAnimationTimer = null;
    let practiceProblem = null;
    
    // --- Builder State ---
    let builderState = {}, activeTool = 'add_point', selectionState = { points: [], features: [] }, builderHistory = [];
    let draggedPointId = null; // ID of the point being dragged
    let wasDragged = false; // Flag to distinguish a click from a drag
    let lastProblemDescription = ''; // Store problem for re-evaluation
    let lastUserAnswers = {}; // Store user answers for re-evaluation
    let lastAiResponse = ''; // Store AI's full internal solution for re-evaluation
    let clickTimeout = null; // Timer to distinguish single vs. double clicks

    // --- UTILITY & GEOMETRY FUNCTIONS ---
    const toRad = deg => deg * Math.PI / 180;
    const toDeg = rad => rad * 180 / Math.PI;
    const polarToCartesian = (angleDeg, radius = R) => ({ x: CX + radius * Math.cos(toRad(angleDeg)), y: CY + radius * Math.sin(toRad(angleDeg)) });
    const cartesianToAngle = p => (toDeg(Math.atan2(p.y - CY, p.x - CX)) + 360) % 360;
    const createSvgElement = (tag, attributes) => {
        const el = document.createElementNS(SVG_NS, tag);
        Object.keys(attributes).forEach(key => el.setAttribute(key, attributes[key]));
        return el;
    };
    const getAngle = (p1, pv, p2) => {
        const v1 = { x: p1.x - pv.x, y: p1.y - pv.y };
        const v2 = { x: p2.x - pv.x, y: p2.y - pv.y };
        const dot = v1.x * v2.x + v1.y * v2.y;
        const mag1 = Math.sqrt(v1.x**2 + v1.y**2);
        const mag2 = Math.sqrt(v2.x**2 + v2.y**2);
        if (mag1 === 0 || mag2 === 0) return 0;
        const acosVal = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
        return toDeg(Math.acos(acosVal));
    };
    const getAngleArcPath = (pVertex, p1, p2, arcRadius) => {
        const angle = getAngle(p1, pVertex, p2);
        if (isNaN(angle) || angle === 0 || angle >= 180) return '';
        const v1 = { x: p1.x - pVertex.x, y: p1.y - pVertex.y };
        const v2 = { x: p2.x - pVertex.x, y: p2.y - pVertex.y };
        const startAngle = Math.atan2(v1.y, v1.x);
        const endAngle = Math.atan2(v2.y, v2.x);
        const start = { x: pVertex.x + arcRadius * Math.cos(startAngle), y: pVertex.y + arcRadius * Math.sin(startAngle) };
        const end = { x: pVertex.x + arcRadius * Math.cos(endAngle), y: pVertex.y + arcRadius * Math.sin(endAngle) };
        const sweepFlag = (v1.x * v2.y - v1.y * v2.x) > 0 ? 1 : 0;
        return `M ${start.x} ${start.y} A ${arcRadius} ${arcRadius} 0 0 ${sweepFlag} ${end.x} ${end.y}`;
    };
    const getAngleBisectorPosition = (pv, pA, pB, distance) => {
        const v1 = { x: pA.x - pv.x, y: pA.y - pv.y };
        const v2 = { x: pB.x - pv.x, y: pB.y - pv.y };
        const mag1 = Math.sqrt(v1.x**2 + v1.y**2);
        const u1 = { x: v1.x / mag1, y: v1.y / mag1 };
        const mag2 = Math.sqrt(v2.x**2 + v2.y**2);
        const u2 = { x: v2.x / mag2, y: v2.y / mag2 };
        const bisectorVec = { x: u1.x + u2.x, y: u1.y + u2.y };
        const magB = Math.sqrt(bisectorVec.x**2 + bisectorVec.y**2);
        if (magB < 0.001) return pv;
        const uB = { x: bisectorVec.x / magB, y: bisectorVec.y / magB };
        return { x: pv.x + uB.x * distance, y: pv.y + uB.y * distance };
    };

    // --- TAB MANAGEMENT ---
    function switchTab(tabId) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.tab[data-tab='${tabId}']`).classList.add('active');
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');
        stopIntroAnimation();
        if (tabId === 'intro') initIntro();
        if (tabId === 'practice') initPractice();
        if (tabId === 'create') initBuilder();
    }

    // --- STANDARD PROBLEM DRAWING (FOR INTRO & PRACTICE) ---
    function drawStandardProblem(svg, arcSpan, opts = {}) {
        if (!svg) return;
        svg.innerHTML = '';
        const p1 = polarToCartesian(180 - arcSpan / 2), p2 = polarToCartesian(180 + arcSpan / 2), p3 = polarToCartesian(0);
        const largeArc = arcSpan > 180 ? 1 : 0;
        svg.appendChild(createSvgElement('path', { d: `M ${p1.x} ${p1.y} A ${R} ${R} 0 ${largeArc} 1 ${p2.x} ${p2.y}`, class: 'key-arc-highlight' }));
        const tanP = p2;
        const tanVec = { x: -(tanP.y - CY), y: (tanP.x - CX) };
        const pTangentNearSide = {x: tanP.x - tanVec.x * 0.5, y: tanP.y - tanVec.y * 0.5};
        const pTangentFarSide = {x: tanP.x + tanVec.x * 0.5, y: tanP.y + tanVec.y * 0.5};
        [
            { x1: CX, y1: CY, x2: p1.x, y2: p1.y }, { x1: CX, y1: CY, x2: p2.x, y2: p2.y },
            { x1: p1.x, y1: p1.y, x2: p3.x, y2: p3.y }, { x1: p2.x, y1: p2.y, x2: p3.x, y2: p3.y },
            { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y },
            { x1: pTangentNearSide.x, y1: pTangentNearSide.y, x2: pTangentFarSide.x, y2: pTangentFarSide.y }
        ].forEach(coords => svg.appendChild(createSvgElement('line', { ...coords, stroke: '#424242' })));
        
        const drawAngle = (pv, pA, pB, color, text, highlight) => {
            const arcRadius = 30;
            const pathData = getAngleArcPath(pv, pA, pB, arcRadius);
            if (!pathData) return;
            const arc = createSvgElement('path', { d: pathData, fill: 'none', stroke: color, 'stroke-width': 2 });
            if (highlight) arc.classList.add('unknown-angle-highlight');
            svg.appendChild(arc);
            if (text) {
                const textPos = getAngleBisectorPosition(pv, pA, pB, arcRadius + 15);
                const angleText = createSvgElement('text', { x: textPos.x, y: textPos.y, fill: color, 'font-size': 18, 'font-weight': 'bold', 'text-anchor': 'middle', dy: '.3em' });
                angleText.textContent = text;
                svg.appendChild(angleText);
            }
        };
        drawAngle({x:CX,y:CY}, p1, p2, 'var(--primary-color)', opts.center, opts.highlight?.includes('center'));
        drawAngle(p3, p1, p2, 'var(--primary-color)', opts.circumference, opts.highlight?.includes('circumference'));
        drawAngle(p2, p1, pTangentNearSide, 'var(--primary-color)', opts.tangent, opts.highlight?.includes('tangent'));
        svg.appendChild(createSvgElement('circle', { cx: CX, cy: CY, r: R, fill: 'none', stroke: '#ccc' }));
    }

    // --- INTRO & PRACTICE PAGES ---
    function initIntro() {
        const content = document.getElementById('intro');
        content.innerHTML = `<div class="main-layout"><div class="intro-content"><div class="theorem-box"><h3>The Core Idea</h3><p>Most circle theorems relate angles to the <strong>arc</strong> they subtend. The key is to find the arc first!</p></div><div class="theorem-box"><h3>Key Theorems</h3><p><strong>Central Angle:</strong> The angle at the centre is double the angle at the circumference from the same arc.</p><p><strong>Alternate Segment:</strong> The angle between a tangent and a chord equals the angle in the alternate segment.</p></div></div><div class="diagram-container"><svg viewBox="0 0 400 400" id="introSvg"></svg></div></div>`;
        const introSvg = document.getElementById('introSvg');
        let angleDeg = 0;
        introAnimationTimer = setInterval(() => {
            angleDeg = (angleDeg + 1) % 360;
            const arcSpan = 120 + 40 * Math.sin(toRad(angleDeg * 2));
            drawStandardProblem(introSvg, arcSpan, { center: '2θ', circumference: 'θ', tangent: 'θ' });
        }, 50);
    }
    function stopIntroAnimation() { clearInterval(introAnimationTimer); introAnimationTimer = null; }

    function initPractice() {
        const content = document.getElementById('practice');
        content.innerHTML = `<div class="main-layout"><div class="problem-area" id="practice-problem-area"></div><div class="diagram-container"><svg viewBox="0 0 400 400" id="practiceSvg"></svg></div></div>`;
        if (!practiceProblem) generatePracticeProblem();
        else renderCurrentPracticeProblem();
    }
    function generatePracticeProblem() {
        const centerAngle = Math.floor(Math.random() * 50 + 20) * 2;
        const givenType = ['center', 'circumference', 'tangent'][Math.floor(Math.random() * 3)];
        practiceProblem = { center: centerAngle, circumference: centerAngle / 2, tangent: centerAngle / 2, given: givenType };
        renderCurrentPracticeProblem();
    }
    function renderCurrentPracticeProblem() {
        if (!practiceProblem) return;
        const practiceSvg = document.getElementById('practiceSvg');
        const labels = { [practiceProblem.given]: `${practiceProblem[practiceProblem.given].toFixed(1)}°` };
        const unknownTypes = Object.keys(practiceProblem).filter(k => k !== 'given' && k !== practiceProblem.given);
        drawStandardProblem(practiceSvg, practiceProblem.center, { ...labels, highlight: unknownTypes });
        const area = document.getElementById('practice-problem-area');
        area.innerHTML = `<h3>Find the missing angles</h3><p>One angle is given. Find the others based on the highlighted elements.</p><div class="input-group">${Object.keys(practiceProblem).filter(k=>k!=='given').map(type => `<div class="angle-input"><label for="practice_${type}">${type.charAt(0).toUpperCase() + type.slice(1)} Angle</label><input type="number" id="practice_${type}" placeholder="Angle in degrees"></div>`).join('')}</div><div class="button-group"><button id="checkAnswerBtn">✓ Check Answer</button><button id="newProblemBtn">🔄 New Problem</button></div><div id="feedback" class="feedback"></div>`;
        document.getElementById('checkAnswerBtn').onclick = checkPracticeAnswer;
        document.getElementById('newProblemBtn').onclick = generatePracticeProblem;
    }
    function checkPracticeAnswer() {
        let allCorrect = true;
        Object.keys(practiceProblem).forEach(type => {
            if (type === 'given') return;
            const input = document.getElementById(`practice_${type}`);
            if (!input || input.disabled) return;
            const userValue = parseFloat(input.value);
            if (isNaN(userValue) || Math.abs(userValue - practiceProblem[type]) > 0.5) {
                allCorrect = false;
                input.classList.add('error');
            } else {
                input.classList.remove('error');
            }
        });
        const feedbackEl = document.getElementById('feedback');
        feedbackEl.className = 'feedback';
        if (allCorrect) {
            feedbackEl.classList.add('success');
            feedbackEl.textContent = '🎉 Correct! Well done!';
        } else {
            feedbackEl.classList.add('error');
            feedbackEl.textContent = 'Not quite. Check the highlighted fields.';
        }
    }

    // --- NEW ADVANCED PROBLEM BUILDER ---
    
    // Helper to get point coordinates by ID
    const getPointCoordsById = (pointId) => {
        const point = builderState.points[pointId];
        if (!point) return null;
        return point.onCircle ? polarToCartesian(point.angle) : { x: point.x, y: point.y };
    };
    
    function initBuilder() {
        const content = document.getElementById('create');
        content.innerHTML = `<div class="main-layout">
            <div class="builder-intro-box">
                <p>Welcome to the Problem Builder! You can:</p>
                <ul>
                    <li><strong>Build a diagram from scratch</strong> using the tools below.</li>
                    <li><strong>Upload an image</strong> of a problem for the AI to analyze and recreate.</li>
                    <li>Set <strong>known values</strong> and mark angles/lengths as <strong>unknowns</strong> to solve.</li>
                    <li>Use the <strong>AI Checker</strong> to verify if your problem is solvable and check your answers.</li>
                </ul>
                <p class="ai-disclaimer">Please note: The AI helper can make mistakes and may be temporarily unavailable during periods of high traffic.</p>
            </div>
            <div class="diagram-container"><svg viewBox="0 0 400 400" id="createSvg"></svg></div>
            
            <div class="toolbox-section">
                <h4>Primary Actions</h4>
                <div class="tool-buttons-grid" id="primary-actions-toolbox">
                    <button class="tool-btn" data-tool="upload_image">🖼️ Upload Problem</button>
                    <button class="tool-btn" data-tool="set_known" disabled>Set Known Value</button>
                    <button class="tool-btn" data-tool="set_unknown" disabled>Set Unknown (?)</button>
                    <button class="tool-btn" data-tool="check_solvability">🤖 AI Check Solvability</button>
                    <button class="tool-btn" data-tool="export_png">🖼️ Export Image</button>
                    <button class="tool-btn" data-tool="reset">🔄 Reset</button>
                </div>
            </div>

            <div class="question-box" id="questionBox">Define knowns and unknowns to build a problem.</div>
            <div class="problem-info" id="createInfo"><p>Select a tool to begin.</p></div>
            
            <div id="toolboxes-container">
                <div class="toolbox-section">
                    <h4>Create</h4>
                    <div class="tool-buttons-grid" id="create-toolbox">
                        <button class="tool-btn" data-tool="add_point">📌 Add Point</button>
                        <button class="tool-btn" data-tool="draw_line">─ Line / Chord</button>
                        <button class="tool-btn" data-tool="draw_radius">─ Radius</button>
                        <button class="tool-btn" data-tool="draw_tangent">─ Tangent at Point</button>
                        <button class="tool-btn" data-tool="define_arc">🌈 Arc</button>
                        <button class="tool-btn" data-tool="define_angle_3pt">∠ Angle (from 3 Pts)</button>
                    </div>
                </div>
                <div class="toolbox-section">
                    <h4>Construct</h4>
                    <div class="tool-buttons-grid" id="construct-toolbox">
                         <button class="tool-btn" data-tool="tangent_from_point">─ Tangent from Point</button>
                        <button class="tool-btn" data-tool="draw_perpendicular">⊥ Draw Perpendicular</button>
                        <button class="tool-btn" data-tool="draw_parallel">∥ Draw Parallel</button>
                        <button class="tool-btn" data-tool="mark_collinear">↔️ Mark Collinear</button>
                        <button class="tool-btn" data-tool="define_angle_vtx">∠ Angle (from Vtx/Lines)</button>
                    </div>
                </div>
                 <div class="toolbox-section">
                    <h4>Modify & Mark</h4>
                    <div class="tool-buttons-grid" id="modify-toolbox">
                        <button class="tool-btn" data-tool="flip_arc" disabled>↔️ Flip Arc</button>
                        <button class="tool-btn" data-tool="extend_line">↔️ Extend Line</button>
                        <button class="tool-btn" data-tool="mark_perp">⊥ Mark Perpendicular</button>
                        <button class="tool-btn" data-tool="mark_equal">= Mark Equal</button>
                        <button class="tool-btn" data-tool="mark_parallel">∥ Mark Parallel</button>
                        <button class="tool-btn" data-tool="undo">↩️ Undo</button>
                        <button class="tool-btn" data-tool="remove" disabled>🗑️ Remove</button>
                    </div>
                </div>
            </div>
            <input type="file" id="imageUpload" accept="image/*" style="display: none;">
        </div>`;
        resetBuilderState();
        setupBuilderEventListeners();
        setActiveTool('add_point');
    }

    function resetBuilderState() {
        builderState = {
            points: { 'p_center': { id: 'p_center', name: 'O', onCircle: false, x: CX, y: CY } },
            features: {}, 
            problem: { knowns: {}, unknowns: {}, additionalGivens: [] }, 
            constraints: {},
        };
        builderHistory.length = 0;
        selectionState = { points: [], features: [] };
    }
    
    function setupBuilderEventListeners() {
        document.getElementById('create').addEventListener('click', e => {
            const toolBtn = e.target.closest('.tool-btn');
            if (toolBtn && toolBtn.dataset.tool) {
                const tool = toolBtn.dataset.tool;
                if (tool === 'undo') {
                    undoLastStep();
                } else if (tool === 'remove') {
                    removeSelectedItems();
                } else if (tool === 'reset') {
                    resetBuilderState();
                    updateBuilderUI();
                } else if (tool === 'export_png') {
                    exportAsPNG();
                } else if (tool === 'set_known') {
                    if (selectionState.features.length === 1) {
                        promptForValue(selectionState.features[0]);
                    }
                } else if (tool === 'set_unknown') {
                    setFeatureAsUnknown();
                } else if (tool === 'flip_arc') {
                    flipSelectedArc();
                } else if (tool === 'check_solvability') {
                    checkSolvability();
                } else if (tool === 'upload_image') {
                    document.getElementById('imageUpload').click();
                }
                else {
                    setActiveTool(tool);
                }
            }
        });

        document.getElementById('imageUpload').addEventListener('change', handleImageUpload);

        const svg = document.getElementById('createSvg');
        svg.addEventListener('click', handleBuilderClick);
        svg.addEventListener('dblclick', handleBuilderDblClick);
        
        // Add dragging listeners
        svg.addEventListener('mousedown', handleDragStart);
        svg.addEventListener('mousemove', handleDrag);
        window.addEventListener('mouseup', handleDragEnd); // Use window to catch mouseup outside svg
    }
    
    function setActiveTool(tool) {
        activeTool = tool;
        selectionState = { points: [], features: [] };
        document.querySelectorAll('#create .tool-btn').forEach(b => b.classList.remove('active'));
        const currentToolBtn = document.querySelector(`#create [data-tool="${tool}"]`);
        if(currentToolBtn) currentToolBtn.classList.add('active');
        updateBuilderUI();
    }
    
    function undoLastStep() {
        const lastAction = builderHistory.pop();
        if (!lastAction) return;
        if (lastAction.type === 'add') {
            lastAction.ids.forEach(id => {
                delete builderState.points[id];
                delete builderState.features[id];
                delete builderState.constraints[id];
                delete builderState.problem.knowns[id];
                delete builderState.problem.unknowns[id];
            });
        }
        selectionState = { points: [], features: [] };
        updateBuilderUI();
    }

    function removeSelectedItems() {
        const pointsToRemove = new Set(selectionState.points);
        const featuresToRemove = new Set(selectionState.features);

        // Broaden removal to include dependent features
        Object.values(builderState.features).forEach(feature => {
            const featurePoints = [feature.p1, feature.p2, feature.pv, feature.pointId].filter(Boolean);
            if (featurePoints.some(pId => pointsToRemove.has(pId))) {
                featuresToRemove.add(feature.id);
            }
        });

        // Perform deletions
        featuresToRemove.forEach(id => {
            delete builderState.features[id];
            delete builderState.problem.knowns[id];
            delete builderState.problem.unknowns[id];
        });
        pointsToRemove.forEach(id => {
            if (id !== 'p_center') { // Don't allow center to be deleted
                delete builderState.points[id];
            }
        });

        // Clear selection and update
        selectionState = { points: [], features: [] };
        updateBuilderUI();
    }

    function handleBuilderDblClick(e){
        clearTimeout(clickTimeout); // Cancel the pending single-click
        clickTimeout = null;
        
        const targetId = e.target.dataset.id;
        const targetIsPointLabel = e.target.matches('.point-label');
        if(targetId && builderState.points[targetId] && targetIsPointLabel && targetId !== 'p_center'){
            const newName = prompt("Enter new name for point:", builderState.points[targetId].name);
            if(newName && newName.trim() !== '') {
                builderState.points[targetId].name = newName.trim();
                updateBuilderUI();
            }
        }
    }

    function handleBuilderClick(e) {
        if (wasDragged) {
            wasDragged = false;
            return;
        }
        
        clearTimeout(clickTimeout); // Clear any pending click from a previous action

        clickTimeout = setTimeout(() => {
            const targetId = e.target.dataset.id;

            if (e.target.matches('.point-label')) {
                // Single click on a label: select the point
                const selectionList = selectionState.points;
                const index = selectionList.indexOf(targetId);
                if (index > -1) {
                    selectionList.splice(index, 1);
                } else {
                    selectionList.push(targetId);
                }
            } else if (targetId) { // Selection logic for points and features
                const isPoint = targetId.startsWith('p');
                const selectionList = isPoint ? selectionState.points : selectionState.features;
                const index = selectionList.indexOf(targetId);
                if (index > -1) {
                    selectionList.splice(index, 1);
                } else {
                    selectionList.push(targetId);
                }
            } else if (activeTool === 'add_point') { // Creation logic
                const svg = document.getElementById('createSvg');
                const CTM = svg.getScreenCTM().inverse();
                const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
                const coords = pt.matrixTransform(CTM);
                const dist = Math.sqrt((coords.x - CX)**2 + (coords.y - CY)**2);
                const onCircle = Math.abs(dist - R) < 25;
                const id = `p${Date.now()}`;
                const name = String.fromCharCode(65 + Object.keys(builderState.points).length -1);
                builderState.points[id] = onCircle ? { id, name, onCircle, angle: cartesianToAngle(coords) } : { id, name, onCircle, x: coords.x, y: coords.y };
                selectionState.points.push(id);
                builderHistory.push({ type: 'add', ids: [id] });
            } else if (activeTool === 'extend_line') {
                const svg = document.getElementById('createSvg');
                const CTM = svg.getScreenCTM().inverse();
                const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
                const clickCoords = pt.matrixTransform(CTM);
                extendSelectedLine(clickCoords);
            }
            applyToolLogic();
            updateBuilderUI();
        }, 200); // 200ms window to detect a double click
    }

    // --- DRAGGING LOGIC ---
    function handleDragStart(e) {
        const targetId = e.target.dataset.id;
        const point = builderState.points[targetId];
        // Allow dragging for any point except the default center
        if (targetId && point && targetId !== 'p_center') {
            draggedPointId = targetId;
            wasDragged = false; // Reset drag flag on new mousedown
            document.getElementById('createSvg').style.cursor = 'move';
        }
    }

    function handleDrag(e) {
        if (!draggedPointId) return;
        wasDragged = true; // If mouse moves while down, it's a drag
        const svg = document.getElementById('createSvg');
        const CTM = svg.getScreenCTM().inverse();
        const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
        const coords = pt.matrixTransform(CTM);
        
        const draggedPoint = builderState.points[draggedPointId];
        if (draggedPoint.onCircle) {
            draggedPoint.angle = cartesianToAngle(coords);
        } else {
            draggedPoint.x = coords.x;
            draggedPoint.y = coords.y;
        }
        renderBuilder(); // Re-render continuously for smooth dragging
    }

    function handleDragEnd(e) {
        if (draggedPointId) {
            if (wasDragged) {
                updateBuilderUI(); // Perform a final update after dragging
            }
            draggedPointId = null;
            document.getElementById('createSvg').style.cursor = 'default';
        }
    }
    
    function flipSelectedArc() {
        const arcId = selectionState.features[0];
        const arc = builderState.features[arcId];
        if(arc && arc.type === 'Arc') {
            arc.isMajor = !arc.isMajor;
            updateBuilderUI();
        }
    }
    
    function extendSelectedLine(clickCoords) {
        if (selectionState.points.length !== 1 || selectionState.features.length !== 1) return;
        
        const lineId = selectionState.features[0];
        const line = builderState.features[lineId];
        if (!line || line.type !== 'Line') return;

        const pointId = selectionState.points[0];
        if (pointId !== line.p1 && pointId !== line.p2) return;

        const p_extend_from_id = pointId;
        const p_other_id = (p_extend_from_id === line.p1) ? line.p2 : line.p1;
        
        const p_extend_from = getPointCoordsById(p_extend_from_id);
        const p_other = getPointCoordsById(p_other_id);

        if (!p_extend_from || !p_other) return;

        const vec = { x: p_extend_from.x - p_other.x, y: p_other.y - p_other.y };
        const mag = Math.sqrt(vec.x**2 + vec.y**2);
        const u_vec = { x: vec.x / mag, y: vec.y / mag };

        const new_p_id = `p${Date.now()}`;
        builderState.points[new_p_id] = { 
            id: new_p_id, 
            name: '', 
            isHidden: true, 
            onCircle: false, 
            x: p_extend_from.x + u_vec.x * 1000, 
            y: p_extend_from.y + u_vec.y * 1000 
        };
        
        line[p_extend_from_id === line.p1 ? 'p1' : 'p2'] = new_p_id;
        
        builderHistory.push({ type: 'add', ids: [new_p_id] }); // Log adding the point
        selectionState = { points: [], features: [lineId] };
        setActiveTool('add_point'); // Reset tool
    }


    function getLineEndpoints(lineFeature) {
        if (!lineFeature) return null;
        if (lineFeature.type === 'Line') {
            const p1 = getPointCoordsById(lineFeature.p1);
            const p2 = getPointCoordsById(lineFeature.p2);
            if (p1 && p2) return { p1, p2 };
        }
        if (lineFeature.type === 'TangentLine') {
            const p_on_circle = getPointCoordsById(lineFeature.pointId);
            if (!p_on_circle) return null;
            const vec_radius = { x: p_on_circle.x - CX, y: p_on_circle.y - CY };
            const vec_tan = { x: -vec_radius.y, y: vec_radius.x };
            const mag = Math.sqrt(vec_tan.x**2 + vec_tan.y**2);
            if (mag === 0) return null;
            const u_tan = { x: vec_tan.x / mag, y: vec_tan.y / mag };
            const p1 = { x: p_on_circle.x - u_tan.x * lineFeature.length, y: p_on_circle.y - u_tan.y * lineFeature.length };
            const p2 = { x: p_on_circle.x + u_tan.x * lineFeature.length, y: p_on_circle.y + u_tan.y * lineFeature.length };
            return { p1, p2 };
        }
        return null;
    }

    function applyToolLogic() {
        const { points, features } = selectionState;
        let actionTaken = false;
        let newIds = [];

        if (activeTool === 'draw_tangent' && points.length === 1 && builderState.points[points[0]]?.onCircle) {
            const id = `f${Date.now()}`;
            builderState.features[id] = { id, type: 'TangentLine', pointId: points[0], extendBefore: true, extendAfter: true, length: 100 };
            newIds.push(id); actionTaken = true;
        } else if (activeTool === 'draw_perpendicular' && points.length === 1 && features.length === 1) {
            const lineF = builderState.features[features[0]];
            const pointP_id = points[0];
            const pointP = getPointCoordsById(pointP_id);
            const endpoints = getLineEndpoints(lineF);

            if (endpoints && pointP) {
                const { p1: A, p2: B } = endpoints;
                const vLine = { x: B.x - A.x, y: B.y - A.y };
                const vPerp = { x: -vLine.y, y: vLine.x };
                const mag = Math.sqrt(vPerp.x**2 + vPerp.y**2);
                const uPerp = { x: vPerp.x / mag, y: vPerp.y / mag };
                
                const newP1_coords = { x: pointP.x + uPerp.x * 1000, y: pointP.y + uPerp.y * 1000 };
                const newP2_coords = { x: pointP.x - uPerp.x * 1000, y: pointP.y - uPerp.y * 1000 };

                const p1_id = `p${Date.now()}`;
                const p2_id = `p${Date.now()+1}`;
                builderState.points[p1_id] = { id: p1_id, name: '', isHidden: true, onCircle: false, ...newP1_coords };
                builderState.points[p2_id] = { id: p2_id, name: '', isHidden: true, onCircle: false, ...newP2_coords };

                const line_id = `f${Date.now()+2}`;
                builderState.features[line_id] = { id: line_id, type: 'Line', p1: p1_id, p2: p2_id };

                newIds.push(p1_id, p2_id, line_id);
                actionTaken = true;
            }
        } else if (activeTool === 'draw_parallel' && points.length === 1 && features.length === 1) {
            const lineF = builderState.features[features[0]];
            const pointP_id = points[0];
            const pointP = getPointCoordsById(pointP_id);
            const endpoints = getLineEndpoints(lineF);

            if (endpoints && pointP) {
                const { p1: A, p2: B } = endpoints;
                const vLine = { x: B.x - A.x, y: B.y - A.y };
                const mag = Math.sqrt(vLine.x**2 + vLine.y**2);
                const uLine = { x: vLine.x / mag, y: vLine.y / mag };

                const newP1_coords = { x: pointP.x + uLine.x * 1000, y: pointP.y + uLine.y * 1000 };
                const newP2_coords = { x: pointP.x - uLine.x * 1000, y: pointP.y - uLine.y * 1000 };
                
                const p1_id = `p${Date.now()}`;
                const p2_id = `p${Date.now()+1}`;
                builderState.points[p1_id] = { id: p1_id, name: '', isHidden: true, onCircle: false, ...newP1_coords };
                builderState.points[p2_id] = { id: p2_id, name: '', isHidden: true, onCircle: false, ...newP2_coords };

                const line_id = `f${Date.now()+2}`;
                builderState.features[line_id] = { id: line_id, type: 'Line', p1: p1_id, p2: p2_id };
                
                newIds.push(p1_id, p2_id, line_id);
                actionTaken = true;
            }
        } else if (activeTool === 'define_arc' && points.length === 2 && points.every(id => builderState.points[id]?.onCircle)) {
            const id = `f${Date.now()}`;
            builderState.features[id] = { id, type: 'Arc', p1: points[0], p2: points[1], isMajor: false };
            newIds.push(id); actionTaken = true;
        } else if (activeTool === 'draw_line' && points.length === 2) {
            const id = `f${Date.now()}`;
            builderState.features[id] = { id, type: 'Line', p1: points[0], p2: points[1] };
            newIds.push(id); actionTaken = true;
        } else if (activeTool === 'draw_radius' && points.length === 1 && builderState.points[points[0]]?.onCircle) {
            const id = `f${Date.now()}`;
            builderState.features[id] = { id, type: 'Line', p1: 'p_center', p2: points[0] };
            newIds.push(id); actionTaken = true;
        } else if (activeTool === 'define_angle_3pt' && points.length === 3) {
            const [p1_id, pv_id, p2_id] = points;
            const angle_id = `f${Date.now()}`;
            const line1_id = `f${Date.now()+1}`;
            const line2_id = `f${Date.now()+2}`;
            
            builderState.features[line1_id] = { id: line1_id, type: 'Line', p1: p1_id, p2: pv_id };
            builderState.features[line2_id] = { id: line2_id, type: 'Line', p1: p2_id, p2: pv_id };
            builderState.features[angle_id] = { id: angle_id, type: 'Angle', p1: p1_id, pv: pv_id, p2: p2_id };
            
            newIds.push(line1_id, line2_id, angle_id);
            actionTaken = true;
        } else if (activeTool === 'define_angle_vtx' && points.length === 1 && features.length === 2) {
            const f1 = builderState.features[features[0]], f2 = builderState.features[features[1]];
            const p_ids = [f1.p1, f1.p2, f2.p1, f2.p2];
            const common_p_id = p_ids.find(id => p_ids.indexOf(id) !== p_ids.lastIndexOf(id));
            if (common_p_id === points[0]) {
                const id = `f${Date.now()}`;
                const p1_id = f1.p1 === common_p_id ? f1.p2 : f1.p1;
                const p2_id = f2.p1 === common_p_id ? f2.p2 : f2.p1;
                builderState.features[id] = { id, type: 'Angle', p1: p1_id, pv: common_p_id, p2: p2_id };
                newIds.push(id); actionTaken = true;
            }
        } else if (activeTool === 'mark_equal' && features.length === 2) {
            const id = `c${Date.now()}`;
            builderState.constraints[id] = {id, type: 'equal', f1: features[0], f2: features[1]};
            newIds.push(id); actionTaken = true;
        } else if (activeTool === 'mark_parallel' && features.length === 2) {
             const id = `c${Date.now()}`;
            builderState.constraints[id] = {id, type: 'parallel', f1: features[0], f2: features[1]};
            newIds.push(id); actionTaken = true;
        } else if (activeTool === 'mark_perp' && features.length === 2) {
            const id = `c${Date.now()}`;
            builderState.constraints[id] = {id, type: 'perpendicular', f1: features[0], f2: features[1]};
            newIds.push(id); actionTaken = true;
        } else if (activeTool === 'mark_collinear' && points.length >= 3) {
            const id = `c${Date.now()}`;
            // Create a copy of the points array for the constraint
            builderState.constraints[id] = {id, type: 'collinear', points: [...points]};
            newIds.push(id);
            actionTaken = true;
        }
        
        if(actionTaken){
            builderHistory.push({ type: 'add', ids: newIds });
            const featureIds = newIds.filter(id => id.startsWith('f'));
            selectionState = { points: [], features: featureIds };
            setActiveTool(activeTool); // Resets selection, updates UI
        }
    }
    
    function setFeatureAsUnknown() {
        const featureId = selectionState.features[0];
        if (!featureId) return;
        builderState.problem.unknowns[featureId] = true;
        delete builderState.problem.knowns[featureId];
        selectionState.features = [];
        updateBuilderUI();
    }

    function promptForValue(featureId) {
        const feature = builderState.features[featureId];
        if (!feature) return;

        let promptText, unit, defaultValue;
        if (feature.type === 'Angle') {
            promptText = 'Enter angle value:'; unit = '°'; defaultValue = '45';
        } else if (feature.type === 'Line') {
            promptText = 'Enter length for line:'; unit = ''; defaultValue = '10';
        } else if (feature.type === 'Arc') {
            promptText = 'Enter arc length:'; unit = ''; defaultValue = '5';
        } else { return; }

        const infoBox = document.getElementById('createInfo');
        infoBox.innerHTML = `
            <div style="padding: 5px;">
                <label for="knownValueInput" style="display:block; margin-bottom:5px;">${promptText}</label>
                <input type="number" id="knownValueInput" value="${defaultValue}" style="width: 80px; padding: 4px; border-radius: 4px; border: 1px solid #999;">
                <span style="margin-left: 4px; font-weight: bold;">${unit}</span>
                <div style="margin-top:10px; display:flex; gap:10px;">
                    <button id="setValueBtn" class="tool-btn active" style="padding: 0.25rem 0.75rem;">Set</button>
                    <button id="cancelValueBtn" class="tool-btn" style="padding: 0.25rem 0.75rem;">Cancel</button>
                </div>
            </div>
        `;

        document.getElementById('setValueBtn').onclick = () => {
            const input = document.getElementById('knownValueInput');
            const value = parseFloat(input.value);
            if (!isNaN(value) && value > 0) {
                builderState.problem.knowns[featureId] = { value, unit };
                delete builderState.problem.unknowns[featureId];
                selectionState.features = [];
                updateBuilderUI();
            } else {
                input.style.borderColor = 'var(--error-color)';
            }
        };

        document.getElementById('cancelValueBtn').onclick = () => {
            updateBuilderUI();
        };
    }

    function createTangentsFromPoint(sourcePointId, numToCreate) {
        const p_data = builderState.points[sourcePointId];
        const p_coords = getPointCoordsById(sourcePointId);
        if (!p_data || !p_coords) return;

        const vec_CP = { x: p_coords.x - CX, y: p_coords.y - CY };
        const d = Math.sqrt(vec_CP.x**2 + vec_CP.y**2);
        if (d <= R) return; // Should have been caught by the UI, but double-check

        const alpha = Math.acos(R / d);
        const angle_CP = Math.atan2(vec_CP.y, vec_CP.x);
        const newElements = [];

        // Tangent 1
        const angle_T1_rad = angle_CP + alpha;
        const t1_angle_deg = toDeg(angle_T1_rad);
        const t1_id = `p${Date.now()}`;
        const t1_name = String.fromCharCode(65 + Object.keys(builderState.points).length - 1);
        builderState.points[t1_id] = { id: t1_id, name: t1_name, onCircle: true, angle: t1_angle_deg };
        
        const line1_id = `f${Date.now()+1}`;
        builderState.features[line1_id] = { id: line1_id, type: 'Line', p1: sourcePointId, p2: t1_id, isTangent: true, extend: false };
        newElements.push(t1_id, line1_id);

        // Tangent 2
        if (numToCreate === 2) {
            const angle_T2_rad = angle_CP - alpha;
            const t2_angle_deg = toDeg(angle_T2_rad);
            const t2_id = `p${Date.now()+2}`;
            const t2_name = String.fromCharCode(65 + Object.keys(builderState.points).length); // Note: no -1
            builderState.points[t2_id] = { id: t2_id, name: t2_name, onCircle: true, angle: t2_angle_deg };

            const line2_id = `f${Date.now()+3}`;
            builderState.features[line2_id] = { id: line2_id, type: 'Line', p1: sourcePointId, p2: t2_id, isTangent: true, extend: false };
            newElements.push(t2_id, line2_id);
        }

        builderHistory.push({ type: 'add', ids: newElements });
        setActiveTool('add_point'); // Reset tool
    }

    function getFeatureName(featureId) {
        const feature = builderState.features[featureId];
        if (!feature) return 'Feature';
        
        const p = (id) => builderState.points[id]?.name || '';

        switch (feature.type) {
            case 'Line':
                if (feature.isTangent) return `Tangent from ${p(feature.p1)} to ${p(feature.p2)}`;
                return `Line ${p(feature.p1)}${p(feature.p2)}`;
            case 'Angle':
                return `∠${p(feature.p1)}${p(feature.pv)}${p(feature.p2)}`;
            case 'Arc':
                return `Arc ${p(feature.p1)}${p(feature.p2)}`;
            case 'TangentLine':
                return `Tangent at ${p(feature.pointId)}`;
            default:
                return feature.type;
        }
    }
    
    // --- AI SOLVABILITY & ANSWER CHECKING ---
    function generateProblemDescription() {
        let description = "This is a geometry problem about a circle with a center O.\n\n";
        description += "The following points exist:\n";
        Object.values(builderState.points).forEach(p => {
            if (p.id === 'p_center') description += `- ${p.name} is the center of the circle.\n`;
            else if (p.onCircle) description += `- Point ${p.name} is on the circle.\n`;
            else if (p.isHidden) return; // Don't describe hidden helper points
            else description += `- Point ${p.name} is outside the circle.\n`;
        });

        description += "\nThe diagram has the following features:\n";
        Object.values(builderState.features).forEach(f => {
            description += `- ${getFeatureName(f.id)}\n`;
        });
        
        const constraints = Object.values(builderState.constraints);
        if (constraints.length > 0) {
            description += "\nThe diagram has the following constraints:\n";
            constraints.forEach(c => {
                if (c.type === 'collinear') {
                    const pointNames = c.points.map(pId => builderState.points[pId]?.name).join(', ');
                    description += `- The points ${pointNames} are collinear (lie on the same straight line).\n`;
                }
                // Add other constraint types here (parallel, perpendicular, etc.)
            });
        }


        const knowns = Object.entries(builderState.problem.knowns);
        const additionalGivens = builderState.problem.additionalGivens || [];
        if (knowns.length > 0 || additionalGivens.length > 0) {
            description += "\nGiven the following information:\n";
            knowns.forEach(([id, data]) => {
                description += `- The measure of ${getFeatureName(id)} is ${data.value}${data.unit || ' units'}.\n`;
            });
            additionalGivens.forEach(given => {
                description += `- ${given}\n`;
            });
        } else {
            description += "\nThere is no given information.\n";
        }

        const unknowns = Object.keys(builderState.problem.unknowns);
        if (unknowns.length > 0) {
            description += "\nFind the measure of:\n";
            unknowns.forEach(id => {
                description += `- ${getFeatureName(id)}\n`;
            });
        } else {
            description += "\nThere is nothing to find.\n";
        }
        
        return description;
    }

    async function checkSolvability() {
        const infoBox = document.getElementById('createInfo');
        lastProblemDescription = generateProblemDescription();
        const { knowns, unknowns } = builderState.problem;

        if (Object.keys(knowns).length === 0 || Object.keys(unknowns).length === 0) {
            infoBox.innerHTML = `<p style="color: var(--error-color);">You must define at least one 'known' value and one 'unknown' value to check solvability.</p>`;
            return;
        }

        infoBox.innerHTML = `<p>🤖 AI is analyzing the problem... please wait.</p>`;

        const prompt = `
            You are an expert high school geometry teacher. Your task is to determine if a circle geometry problem is solvable using standard theorems.
            Here is the problem:
            ${lastProblemDescription}
            Based ONLY on the information provided, is it possible to find the value of all the 'Find' items? 
            Please respond with a single word: 'Solvable', 'Unsolvable', or 'Partially Solvable'. 
            Then, provide a brief, one-sentence explanation for your reasoning.
        `;

        try {
            const aiResponseText = await callGemini(prompt);
            lastAiResponse = aiResponseText; // Store the initial assessment
            
            if (aiResponseText.toLowerCase().startsWith('solvable')) {
                presentProblemToSolve();
            } else {
                infoBox.innerHTML = `<p><strong>AI Checker Result:</strong><br>${aiResponseText.replace(/\n/g, '<br>')}</p>`;
                
                const challengeBtn = document.createElement('button');
                challengeBtn.className = 'tool-btn';
                challengeBtn.style.cssText = 'width: 100%; text-align: center; margin-top: 1rem; border-color: var(--highlight-color); color: var(--highlight-color);';
                challengeBtn.textContent = "Challenge AI's Assessment";
                challengeBtn.onclick = handleSolvabilityChallenge;
                infoBox.appendChild(challengeBtn);
            }

        } catch (error) {
            console.error("Error calling AI model:", error);
            infoBox.innerHTML = `<p style="color: var(--error-color);">Error checking solvability: ${error.message}. Please check the console for details.</p>`;
        }
    }

    function presentProblemToSolve() {
        const infoBox = document.getElementById('createInfo');
        const { unknowns } = builderState.problem;
        
        let inputsHTML = Object.keys(unknowns).map(id => {
            const featureName = getFeatureName(id);
            return `
                <div class="angle-input" style="font-family: sans-serif;">
                    <label for="user_answer_${id}">${featureName}</label>
                    <input type="number" id="user_answer_${id}" placeholder="Enter value">
                </div>
            `;
        }).join('');

        infoBox.innerHTML = `
            <h4 style="color: var(--primary-color); margin-bottom: 1rem;">Problem is Solvable!</h4>
            <p style="margin-bottom: 1rem;">Based on the diagram and knowns, find the value for the following:</p>
            <div class="input-group">${inputsHTML}</div>
            <button id="checkUserAnswerBtn" class="tool-btn active" style="width: 100%; text-align: center;">Check My Answer</button>
            <div id="aiAnswerFeedback" style="margin-top: 1rem;"></div>
        `;

        document.getElementById('checkUserAnswerBtn').onclick = handleAnswerCheck;
    }

    async function handleAnswerCheck() {
        const { unknowns } = builderState.problem;
        lastUserAnswers = {};
        Object.keys(unknowns).forEach(id => {
            const input = document.getElementById(`user_answer_${id}`);
            lastUserAnswers[getFeatureName(id)] = input.value;
        });
        
        const feedbackDiv = document.getElementById('aiAnswerFeedback');
        feedbackDiv.innerHTML = `<p>🤖 AI is checking your answer...</p>`;

        let userAnswersString = Object.entries(lastUserAnswers)
            .map(([name, value]) => `- The user's answer for ${name} is ${value || 'not provided'}.`)
            .join('\n');

        const prompt = `
            You are a helpful high school geometry teacher AI. A student has created a geometry problem and has attempted to solve it.
            
            Here is the problem description:
            ${lastProblemDescription}

            Here are the user's answers:
            ${userAnswersString}

            Your task is to solve the problem yourself. Provide only the key steps and the final answers. Be concise and focus on the main line of reasoning and the theorems used. For example: "1. ∠AOB = 80° (Angle at center is twice angle at circumference). 2. Therefore, ∠ACB = 40°."

            After your solution, compare your final answers to the user's answers internally. Then, on a new line, add ONE of the following tags and nothing else:
            - If all the user's answers match yours: [CORRECT]
            - If any of the user's answers do not match yours: [INCORRECT]
        `;

        try {
            const fullAiResponse = await callGemini(prompt);
            lastAiResponse = fullAiResponse; // Store the full reasoning
            
            const userIsCorrect = fullAiResponse.includes("[CORRECT]");
            const solutionText = fullAiResponse.split("[")[0].trim();

            if(userIsCorrect) {
                feedbackDiv.innerHTML = `<p style="color: var(--success-color);">🎉 Correct! Your answers match the AI's solution.</p>`;
            } else {
                feedbackDiv.innerHTML = `<p style="color: var(--error-color);">Our answers don't seem to match. One of us may have made a mistake.</p>`;
            }
            
            const challengeBtn = document.createElement('button');
            challengeBtn.className = 'tool-btn';
            challengeBtn.style.cssText = 'width: 100%; text-align: center; margin-top: 1rem; border-color: var(--highlight-color); color: var(--highlight-color);';
            challengeBtn.textContent = "Show AI's Full Solution";
            challengeBtn.onclick = () => showAiSolution(solutionText); // Pass only the solution part
            feedbackDiv.appendChild(challengeBtn);

        } catch (error) {
            console.error("Error calling AI model for answer check:", error);
            feedbackDiv.innerHTML = `<p style="color: var(--error-color);">Error checking answer: ${error.message}.</p>`;
        }
    }

    function showAiSolution(solutionText) {
        const feedbackDiv = document.getElementById('aiAnswerFeedback');
        // The "### My Solution" heading is removed from the prompt, so no need to strip it.
        feedbackDiv.innerHTML = `<p><strong>AI's Full Solution:</strong><br>${solutionText.replace(/\n/g, '<br>')}</p>`;

        const challengeBtn = document.createElement('button');
        challengeBtn.className = 'tool-btn';
        challengeBtn.style.cssText = 'width: 100%; text-align: center; margin-top: 1rem; border-color: var(--highlight-color); color: var(--highlight-color);';
        challengeBtn.textContent = "I still believe my answer is correct. Challenge AI.";
        challengeBtn.onclick = handleChallenge;
        feedbackDiv.appendChild(challengeBtn);
    }

    function handleChallenge() {
        const feedbackDiv = document.getElementById('aiAnswerFeedback');
        feedbackDiv.innerHTML = `
            <p style="font-family: sans-serif; margin-bottom: 0.5rem;">Please explain your reasoning below:</p>
            <textarea id="challengeText" class="challenge-textarea" rows="4" placeholder="For example: 'I used the alternate segment theorem on chord AC...'"></textarea>
            <button id="submitChallengeBtn" class="tool-btn active" style="width: 100%; text-align: center; margin-top: 0.5rem;">Submit Correction to AI</button>
        `;
        document.getElementById('submitChallengeBtn').onclick = submitChallenge;
    }

    async function submitChallenge() {
        const feedbackDiv = document.getElementById('aiAnswerFeedback');
        const userReasoning = document.getElementById('challengeText').value;
        if (!userReasoning) {
            alert("Please provide your reasoning.");
            return;
        }

        feedbackDiv.innerHTML = `<p>🤖 AI is re-evaluating based on your feedback...</p>`;
        
        let userAnswersString = Object.entries(lastUserAnswers)
            .map(([name, value]) => `- The user's answer for ${name} is ${value || 'not provided'}.`)
            .join('\n');

        const prompt = `
            You are a humble and expert high school geometry teacher AI. You previously evaluated a student's answer and they have challenged your conclusion. You must re-evaluate everything with an open mind, as you may have made a mistake.

            **Original Problem:**
            ${lastProblemDescription}

            **Student's Answers:**
            ${userAnswersString}

            **Your Previous Internal Step-by-Step Solution (which you must now re-evaluate):**
            ${lastAiResponse.split("[")[0].trim()}

            **The Student's Challenge and Reasoning:**
            "${userReasoning}"

            **Your Task:**
            Carefully re-read the original problem. Critically analyze your previous step-by-step solution. Then, carefully consider the student's reasoning.
            - If the student is correct and you were wrong, you MUST admit your mistake clearly and apologize. Then, provide the new, corrected step-by-step solution, keeping it concise and focused on the key logical steps.
            - If the student's reasoning is flawed and your original answer was correct, politely and respectfully explain the specific error in THEIR reasoning, referencing their argument directly.
        `;

        try {
            const aiResponseText = await callGemini(prompt);
            feedbackDiv.innerHTML = `<p><strong>AI Re-evaluation:</strong><br>${aiResponseText.replace(/\n/g, '<br>')}</p>`;
        } catch (error) {
            console.error("Error calling AI model for re-evaluation:", error);
            feedbackDiv.innerHTML = `<p style="color: var(--error-color);">Error during re-evaluation: ${error.message}.</p>`;
        }
    }

    function handleSolvabilityChallenge() {
        const infoBox = document.getElementById('createInfo');
        infoBox.innerHTML = `
            <p style="font-family: sans-serif; margin-bottom: 0.5rem;">Please explain why you believe the problem is solvable:</p>
            <textarea id="solvabilityChallengeText" class="challenge-textarea" rows="4" placeholder="For example: 'The problem is solvable because if you extend line AB to point D...'"></textarea>
            <button id="submitSolvabilityChallengeBtn" class="tool-btn active" style="width: 100%; text-align: center; margin-top: 0.5rem;">Submit Challenge to AI</button>
        `;
        document.getElementById('submitSolvabilityChallengeBtn').onclick = submitSolvabilityChallenge;
    }

    async function submitSolvabilityChallenge() {
        const infoBox = document.getElementById('createInfo');
        const userReasoning = document.getElementById('solvabilityChallengeText').value;
        if (!userReasoning) {
            alert("Please provide your reasoning.");
            return;
        }

        infoBox.innerHTML = `<p>🤖 AI is re-evaluating solvability based on your feedback...</p>`;

        const prompt = `
            You are a humble and expert high school geometry teacher AI. You previously assessed a problem as unsolvable. A student has challenged you, providing new reasoning.
            **Original Problem:**
            ${lastProblemDescription}
            **Your Previous Assessment:**
            "${lastAiResponse}"
            **The Student's New Reasoning:**
            "${userReasoning}"

            **Your Task:**
            Analyze the student's new reasoning.
            1. Is the problem now solvable with this new information?
            2. If it is now solvable, what is the key piece of new information the user provided? (e.g., "Angle ABC is a right angle", "Line DE is parallel to BC").

            Respond ONLY with a JSON object in the following format. Do not add any other text or explanation outside the JSON block.

            If now solvable:
            \`\`\`json
            {
              "isSolvable": true,
              "newInformation": "A concise statement of the new fact provided by the user."
            }
            \`\`\`

            If still not solvable:
            \`\`\`json
            {
              "isSolvable": false,
              "reason": "A single, polite sentence explaining why the student's reasoning is incorrect or insufficient."
            }
            \`\`\`
        `;

        try {
            let jsonResponse = await callGemini(prompt);
            const jsonMatch = jsonResponse.match(/```json\s*([\s\S]*?)\s*```/);
            if (!jsonMatch || !jsonMatch[1]) {
                throw new Error("AI did not return a valid JSON response for the solvability challenge.");
            }
            const parsedData = JSON.parse(jsonMatch[1]);

            if (parsedData.isSolvable) {
                // If the AI agrees, add the new info to the problem statement and present the solving fields
                if (parsedData.newInformation) {
                    builderState.problem.additionalGivens.push(parsedData.newInformation);
                    generateQuestionText(); // Update the displayed question
                }
                presentProblemToSolve();
            } else {
                // If the AI disagrees, show the reason and offer another chance to challenge
                infoBox.innerHTML = `<p><strong>AI Re-evaluation:</strong><br>${parsedData.reason}</p>`;
                const challengeBtn = document.createElement('button');
                challengeBtn.className = 'tool-btn';
                challengeBtn.style.cssText = 'width: 100%; text-align: center; margin-top: 1rem; border-color: var(--highlight-color); color: var(--highlight-color);';
                challengeBtn.textContent = "Provide More Information";
                challengeBtn.onclick = handleSolvabilityChallenge;
                infoBox.appendChild(challengeBtn);
            }
        } catch (error) {
            console.error("Error calling AI model for solvability re-evaluation:", error);
            infoBox.innerHTML = `<p style="color: var(--error-color);">Error during re-evaluation: ${error.message}.</p>`;
        }
    }
    
    async function callGemini(prompt, base64ImageData = null) {
        // This relative URL is the standard and most robust method for deployed web apps.
        const apiUrl = '/api/gemini';

        let userParts = [{ text: prompt }];
        if (base64ImageData) {
            userParts.push({
                inlineData: {
                    mimeType: "image/png",
                    data: base64ImageData
                }
            });
        }
        
        const payload = { 
            contents: [{ role: "user", parts: userParts }]
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorBody = await response.text();
            console.error("API Error Response:", errorBody);
            throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        
        if (result.error) {
             throw new Error(`AI API returned an error: ${result.error.message}`);
        }

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
            return result.candidates[0].content.parts[0].text;
        }
        
        throw new Error("Could not get a clear response from the AI.");
    }

    async function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const infoBox = document.getElementById('createInfo');
        infoBox.innerHTML = `<p>🤖 AI is analyzing the uploaded image... please wait.</p>`;

        const reader = new FileReader();
        reader.onloadend = async () => {
            const base64ImageData = reader.result.split(',')[1];
            
            const prompt = `
                Analyze this image of a circle geometry problem. Identify the key geometric elements.
                Respond ONLY with a JSON object that follows this structure, wrapped in markdown code fences (\`\`\`json ... \`\`\`).
                {
                  "points": [
                    {"name": "A", "onCircle": true, "normalizedX": 0.5, "normalizedY": 0.1},
                    {"name": "O", "onCircle": false, "normalizedX": 0.5, "normalizedY": 0.5}
                  ],
                  "lines": [
                    {"point1Name": "A", "point2Name": "B"},
                    {"point1Name": "O", "point2Name": "C"}
                  ]
                }
                - 'name' is the letter label of the point.
                - 'onCircle' is true if the point is on the circumference, false otherwise.
                - 'normalizedX' and 'normalizedY' are the coordinates of the point from 0.0 (left/top) to 1.0 (right/bottom).
                - 'lines' are defined by the names of the two points they connect.
            `;

            try {
                let jsonResponse = await callGemini(prompt, base64ImageData);
                
                // Clean the response to extract only the JSON
                const jsonMatch = jsonResponse.match(/```json\s*([\s\S]*?)\s*```/);
                if (!jsonMatch || !jsonMatch[1]) {
                    console.error("Raw AI Response:", jsonResponse);
                    throw new Error("AI did not return a valid JSON code block.");
                }
                jsonResponse = jsonMatch[1];

                const parsedData = JSON.parse(jsonResponse);
                
                // Rebuild the state from the parsed data
                resetBuilderState();
                // If the image contains a center point O, remove the default one
                if (parsedData.points.some(p => p.name === 'O' && !p.onCircle)) {
                    delete builderState.points.p_center;
                }

                const nameToIdMap = {};
                let pointCounter = 0;

                parsedData.points.forEach(p => {
                    const id = (p.name === 'O' && !p.onCircle) ? 'p_center' : `p_img_${pointCounter++}`;
                    nameToIdMap[p.name] = id;
                    const svgX = p.normalizedX * 400;
                    const svgY = p.normalizedY * 400;

                    if (p.onCircle) {
                        const angle = cartesianToAngle({x: svgX, y: svgY});
                        builderState.points[id] = { id, name: p.name, onCircle: true, angle };
                    } else {
                         builderState.points[id] = { id, name: p.name, onCircle: false, x: svgX, y: svgY };
                    }
                });

                parsedData.lines.forEach(l => {
                    const id = `f_img_${Date.now()}_${Math.random()}`;
                    const p1_id = nameToIdMap[l.point1Name];
                    const p2_id = nameToIdMap[l.point2Name];
                    if (p1_id && p2_id) {
                        builderState.features[id] = { id, type: 'Line', p1: p1_id, p2: p2_id };
                    }
                });

                infoBox.innerHTML = `<p>Diagram created from image! You can now make amendments, and set the knowns and unknowns.</p>`;
                updateBuilderUI();

            } catch (error) {
                console.error("Error analyzing image:", error);
                infoBox.innerHTML = `<p style="color: var(--error-color);">Error analyzing image. The AI's response might have been malformed. Please try again or build the diagram manually.</p>`;
            }
        };
        reader.readAsDataURL(file);
    }


    function updateBuilderUI() {
        const { points, features } = selectionState;
        const messages = {
            add_point: "Click to add a point. Click near the circle to snap to it. Double-click a point's label to rename it.",
            draw_line: `Select 2 points to create a line/chord. [${points.length}/2]`,
            draw_radius: `Select 1 point on the circle to draw a radius. [${points.length}/1]`,
            draw_tangent: `Select 1 point on the circle to create a tangent. [${points.length}/1]`,
            define_arc: `Select 2 points on the circle to define an arc. [${points.length}/2]`,
            define_angle_3pt: `Select 3 points for the angle (endpoint, vertex, endpoint). [${points.length}/3]`,
            define_angle_vtx: `Select 2 lines and their common vertex. [${features.length}/2, ${points.length}/1]`,
            tangent_from_point: `Select 1 point outside the circle to construct tangents. [${points.length}/1]`,
            draw_perpendicular: `Select 1 line and 1 point to draw a perpendicular line through. [${features.length}/1, ${points.length}/1]`,
            draw_parallel: `Select 1 line and 1 point to draw a parallel line through. [${features.length}/1, ${points.length}/1]`,
            mark_collinear: `Select 3 or more points to mark as collinear. [${points.length}/3+]`,
            extend_line: `Select a line and one of its endpoints to extend it. [${features.length}/1, ${points.length}/1]`,
            mark_equal: `Select 2 features (lines or arcs). [${features.length}/2]`,
            mark_parallel: `Select 2 lines. [${features.length}/2]`,
            mark_perp: `Select 2 intersecting lines. [${features.length}/2]`
        };
        
        let infoContent = `<p>${messages[activeTool] || "Select items to apply a tool."}</p>`;
        
        // --- UI for Tangent from Point ---
        if (activeTool === 'tangent_from_point' && points.length === 1) {
            const p_id = points[0];
            const p_data = builderState.points[p_id];
            if (p_data && !p_data.onCircle) {
                const p_coords = getPointCoordsById(p_id);
                const dist = Math.sqrt((p_coords.x - CX)**2 + (p_coords.y - CY)**2);
                if (dist > R + 1e-6) { // Point is outside
                    infoContent = `
                        <p>Create tangent(s) from point ${p_data.name}.</p>
                        <div style="display:flex; flex-direction: column; gap:0.5rem; margin-top:0.5rem;">
                            <button class="tool-btn" onclick="createTangentsFromPoint('${p_id}', 1)">Draw 1 Tangent</button>
                            <button class="tool-btn" onclick="createTangentsFromPoint('${p_id}', 2)">Draw 2 Tangents</button>
                        </div>
                    `;
                } else {
                    infoContent = `<p style="color: var(--error-color);">Point must be outside the circle to draw tangents.</p>`;
                }
            }
        }

        document.getElementById('createInfo').innerHTML = infoContent;

        // --- Enable/Disable Tool Buttons ---
        const selectedFeature = builderState.features[features[0]];
        const isTangentSelected = features.length === 1 && selectedFeature && (selectedFeature.isTangent || selectedFeature.type === 'TangentLine');
        
        document.querySelector('[data-tool="flip_arc"]').disabled = !(features.length === 1 && selectedFeature?.type === 'Arc');
        document.querySelector('[data-tool="set_known"]').disabled = features.length !== 1;
        document.querySelector('[data-tool="set_unknown"]').disabled = features.length !== 1;
        document.querySelector('[data-tool="undo"]').disabled = builderHistory.length === 0;
        document.querySelector('[data-tool="remove"]').disabled = points.length === 0 && features.length === 0;
        
        generateQuestionText();
        renderBuilder();
    }
    
    function generateQuestionText() {
        const questionBox = document.getElementById('questionBox');
        if (!questionBox) return;

        const knowns = Object.entries(builderState.problem.knowns);
        const unknowns = Object.keys(builderState.problem.unknowns);
        const additionalGivens = builderState.problem.additionalGivens || [];

        if (knowns.length === 0 && unknowns.length === 0 && additionalGivens.length === 0) {
            questionBox.innerHTML = 'Define knowns and unknowns to build a problem.';
            return;
        }

        let text = '<strong>Given:</strong> ';
        let givens = knowns.map(([id, data]) => {
            return `${getFeatureName(id)} = ${data.value}${data.unit || ''}`;
        });
        givens = givens.concat(additionalGivens);

        text += givens.join(', ') || 'None';

        if (unknowns.length > 0) {
            text += '<br><strong>Find:</strong> ';
            text += unknowns.map(id => getFeatureName(id)).join(', ');
        }
        questionBox.innerHTML = text;
    }

    function renderBuilder() {
        const svg = document.getElementById('createSvg');
        if (!svg) return;
        svg.innerHTML = '';
        svg.appendChild(createSvgElement('circle', { cx: CX, cy: CY, r: R, fill: '#f9f9f9', stroke: '#e0e0e0', 'stroke-width': '2' }));
        
        // Render Collinear Constraints first (as background lines)
        Object.values(builderState.constraints).forEach(c => {
            if (c.type === 'collinear' && c.points.length >= 2) {
                const coords = c.points.map(pId => getPointCoordsById(pId)).filter(Boolean);
                if (coords.length < 2) return;

                // Find the two extreme points to define the line segment
                let minXPoint = coords[0], maxXPoint = coords[0];
                coords.forEach(p => {
                    if (p.x < minXPoint.x) minXPoint = p;
                    if (p.x > maxXPoint.x) maxXPoint = p;
                });

                // Extend the line slightly for better visibility
                const vec = { x: maxXPoint.x - minXPoint.x, y: maxXPoint.y - minXPoint.y };
                const mag = Math.sqrt(vec.x**2 + vec.y**2);
                const uVec = { x: vec.x / mag, y: vec.y / mag };
                
                const p1 = { x: minXPoint.x - uVec.x * 20, y: minXPoint.y - uVec.y * 20 };
                const p2 = { x: maxXPoint.x + uVec.x * 20, y: maxXPoint.y + uVec.y * 20 };

                svg.appendChild(createSvgElement('line', {
                    x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
                    stroke: 'var(--dark-gray)', 'stroke-width': 1.5, 'stroke-dasharray': '5,5',
                    opacity: 0.6
                }));
            }
        });


        Object.values(builderState.features).forEach(f => {
            const isSelected = selectionState.features.includes(f.id);
            const pathAttrs = {
                'data-id': f.id, class: 'selectable',
                stroke: 'var(--primary-color)', 'stroke-width': 3, fill: 'none'
            };
            if(isSelected) pathAttrs.class += ' selected-outline';

            if (f.type === 'Line') {
                const p1 = getPointCoordsById(f.p1);
                const p2 = getPointCoordsById(f.p2);
                if (p1 && p2) {
                    svg.appendChild(createSvgElement('line', { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, ...pathAttrs }));
                }
            } else if (f.type === 'TangentLine') {
                const p_on_circle = getPointCoordsById(f.pointId);
                if (!p_on_circle) return;
                const vec_radius = { x: p_on_circle.x - CX, y: p_on_circle.y - CY };
                const vec_tan = { x: -vec_radius.y, y: vec_radius.x };
                const mag = Math.sqrt(vec_tan.x**2 + vec_tan.y**2);
                if (mag === 0) return;
                const u_tan = { x: vec_tan.x / mag, y: vec_tan.y / mag };
                
                const startPt = f.extendBefore ? { x: p_on_circle.x - u_tan.x * f.length, y: p_on_circle.y - u_tan.y * f.length } : p_on_circle;
                const endPt = f.extendAfter ? { x: p_on_circle.x + u_tan.x * f.length, y: p_on_circle.y + u_tan.y * f.length } : p_on_circle;
                
                svg.appendChild(createSvgElement('line', { x1: startPt.x, y1: startPt.y, x2: endPt.x, y2: endPt.y, ...pathAttrs }));

            } else if (f.type === 'Arc') {
                const p1_data = builderState.points[f.p1];
                const p2_data = builderState.points[f.p2];
                const p1 = getPointCoordsById(f.p1);
                const p2 = getPointCoordsById(f.p2);

                if (p1 && p2 && p1_data && p2_data) {
                    const ccw_angle_diff = (p2_data.angle - p1_data.angle + 360) % 360;
                    const is_ccw_path_major = ccw_angle_diff > 180;
                    const largeArcFlag = f.isMajor ? 1 : 0;
                    const sweepFlag = (f.isMajor === is_ccw_path_major) ? 1 : 0;

                    pathAttrs.d = `M ${p1.x} ${p1.y} A ${R} ${R} 0 ${largeArcFlag} ${sweepFlag} ${p2.x} ${p2.y}`;
                    pathAttrs.class += ' builder-arc';
                    svg.appendChild(createSvgElement('path', pathAttrs));
                    
                    if (isSelected) {
                        const complementLargeArcFlag = largeArcFlag === 1 ? 0 : 1;
                        const complementSweepFlag = sweepFlag === 1 ? 0 : 1;
                        const complementPathAttrs = {
                            d: `M ${p1.x} ${p1.y} A ${R} ${R} 0 ${complementLargeArcFlag} ${complementSweepFlag} ${p2.x} ${p2.y}`,
                            stroke: 'var(--highlight-color)', 'stroke-width': 4, fill: 'none', 'pointer-events': 'none'
                        };
                        svg.appendChild(createSvgElement('path', complementPathAttrs));
                    }
                }
            } else if (f.type === 'Angle') {
                const p1 = getPointCoordsById(f.p1), pv = getPointCoordsById(f.pv), p2 = getPointCoordsById(f.p2);
                if (p1 && pv && p2) {
                    pathAttrs.d = getAngleArcPath(pv, p1, p2, 25);
                    if(pathAttrs.d) svg.appendChild(createSvgElement('path', pathAttrs));
                }
            }
        });

        Object.values(builderState.points).forEach(p => {
            if (p.isHidden) return; // Don't render hidden points
            const pos = getPointCoordsById(p.id);
            if (!pos) return;
            const pointEl = p.onCircle ? createSvgElement('circle', { cx: pos.x, cy: pos.y, r: 8 }) : createSvgElement('rect', { x: pos.x - 6, y: pos.y - 6, width: 12, height: 12 });
            if (p.id === 'p_center') { pointEl.setAttribute('fill', '#333'); } else { pointEl.setAttribute('fill', 'var(--primary-color)'); }
            pointEl.setAttribute('data-id', p.id);
            pointEl.classList.add('selectable');
            if (p.id !== 'p_center') pointEl.classList.add('draggable-point');
            if(selectionState.points.includes(p.id)) pointEl.classList.add('selected-outline');
            svg.appendChild(pointEl);
            const textEl = createSvgElement('text', { x: pos.x, y: pos.y - 15, 'text-anchor': 'middle', 'font-weight': 'bold', 'fill': '#333', 'data-id': p.id, class: 'point-label' });
            textEl.textContent = p.name;
            svg.appendChild(textEl);
        });

        const allProblemItems = [...Object.entries(builderState.problem.knowns), ...Object.keys(builderState.problem.unknowns).map(id => [id, { value: '?' }])];
        allProblemItems.forEach(([id, data]) => {
            const feature = builderState.features[id];
            if (!feature) return;

            let pos;
            let textContent = `${data.value}${data.unit || ''}`;

            if (feature.type === 'Line' || feature.type === 'TangentLine') {
                const endpoints = getLineEndpoints(feature);
                if (!endpoints) return;
                const {p1, p2} = endpoints;
                pos = { x: (p1.x + p2.x) / 2 + 5, y: (p1.y + p2.y) / 2 - 5 };
            } else if (feature.type === 'Angle') {
                const p1 = getPointCoordsById(feature.p1);
                const pv = getPointCoordsById(feature.pv);
                const p2 = getPointCoordsById(feature.p2);
                if (!p1 || !pv || !p2) return;
                pos = getAngleBisectorPosition(pv, p1, p2, 40);
            } else if (feature.type === 'Arc') {
                const p1_data = builderState.points[feature.p1];
                const p2_data = builderState.points[feature.p2];
                if (!p1_data || !p2_data) return;
                const a1 = p1_data.angle;
                const a2 = p2_data.angle;
                const ccw_angle_diff = (a2 - a1 + 360) % 360;
                const is_ccw_path_major = ccw_angle_diff > 180;
                const use_ccw_path = (feature.isMajor === is_ccw_path_major);
                let midAngle;
                if (use_ccw_path) {
                    midAngle = a1 + ccw_angle_diff / 2;
                } else {
                    midAngle = a2 + (360 - ccw_angle_diff) / 2;
                }
                pos = polarToCartesian(midAngle, R + 20);
            }

            if (pos) {
                const textEl = createSvgElement('text', { x: pos.x, y: pos.y, 'text-anchor': 'middle', dy: '.3em', class: 'feature-label' });
                textEl.textContent = textContent;
                svg.appendChild(textEl);
            }
        });
    }
    
    function exportAsPNG() {
        const svgElement = document.getElementById('createSvg');
        if (!svgElement) return;

        const selected = svgElement.querySelectorAll('.selected-outline');
        selected.forEach(el => el.classList.remove('selected-outline'));

        let css = '';
        for (const sheet of document.styleSheets) {
            try {
                for (const rule of sheet.cssRules) { css += rule.cssText; }
            } catch (e) {
                console.warn("Cannot read cross-origin stylesheet.", e);
            }
        }
        
        const svgClone = svgElement.cloneNode(true);
        const styleElement = document.createElementNS(SVG_NS, "style");
        styleElement.textContent = css;
        svgClone.insertBefore(styleElement, svgClone.firstChild);

        const serializer = new XMLSerializer();
        let svgString = serializer.serializeToString(svgClone);

        selected.forEach(el => el.classList.add('selected-outline'));

        const canvas = document.createElement('canvas');
        const svgSize = svgElement.viewBox.baseVal;
        canvas.width = svgSize.width;
        canvas.height = svgSize.height;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const img = new Image();
        const blob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
        const url = URL.createObjectURL(blob);

        img.onload = function() {
            ctx.drawImage(img, 0, 0);
            URL.revokeObjectURL(url);

            const a = document.createElement('a');
            a.href = canvas.toDataURL('image/png');
            a.download = 'circle-diagram.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
        img.src = url;
    }

    // --- INITIALIZE APP ---
    document.addEventListener('DOMContentLoaded', () => {
        document.querySelector('.tabs').addEventListener('click', e => {
            if (e.target.matches('.tab')) {
                switchTab(e.target.dataset.tab);
            }
        });
        switchTab('intro');
    });
    </script>
</body>
</html>

